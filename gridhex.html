<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixiJS Hexagon Grid</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.3.3/pixi.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        #hexCanvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="hexCanvas"></div>
    <script>
        const app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            backgroundColor: 0x87CEEB,
            resolution: window.devicePixelRatio || 1,
        });

        document.getElementById('hexCanvas').appendChild(app.view);

        const hexRadius = 15;
        const hexHeight = hexRadius * Math.sqrt(3);
        const hexWidth = hexRadius * 2;

        const gridWidth = 250;
        const gridHeight = 100;

        const hexContainer = new PIXI.Container();
        app.stage.addChild(hexContainer);

        const terrainTypes = {
            water: 0x5B99C2,
            beach: 0xF9DBBA,
            grass: 0xCBE2B5,
            forest: 0x86AB89,
            mountain: 0xA28B55
        };

        const noise = new SimplexNoise();

        function getTerrainType(noiseValue) {
            if (noiseValue < -0.3) return 'water';
            if (noiseValue < -0.1) return 'beach';
            if (noiseValue < 0.2) return 'grass';
            if (noiseValue < 0.5) return 'forest';
            return 'mountain';
        }

        function createHexagon(x, y, i, j, k) {
            const hexagon = new PIXI.Graphics();
            const noiseValue = noise.noise2D(i * 0.05, j * 0.05);
            const terrain = getTerrainType(noiseValue);
            hexagon.beginFill(terrainTypes[terrain]);
            hexagon.lineStyle(1, 0x000000);
            hexagon.drawPolygon([
                -hexRadius, 0,
                -hexRadius / 2, hexHeight / 2,
                hexRadius / 2, hexHeight / 2,
                hexRadius, 0,
                hexRadius / 2, -hexHeight / 2,
                -hexRadius / 2, -hexHeight / 2
            ]);
            hexagon.endFill();
            hexagon.x = x;
            hexagon.y = y;
            hexagon.i = i;
            hexagon.j = j;
            hexagon.k = k;
            hexagon.terrain = terrain;

            hexagon.interactive = true;
            hexagon.buttonMode = true;
            hexagon.clicked = false;

            hexagon.on('pointerdown', () => {
                hexagon.clear();
                hexagon.beginFill(0xFF0000);
                hexagon.lineStyle(1, 0x000000);
                hexagon.drawPolygon([
                    -hexRadius, 0,
                    -hexRadius / 2, hexHeight / 2,
                    hexRadius / 2, hexHeight / 2,
                    hexRadius, 0,
                    hexRadius / 2, -hexHeight / 2,
                    -hexRadius / 2, -hexHeight / 2
                ]);
                hexagon.endFill();
                hexagon.clicked = true;
            });

            return hexagon;
        }

        for (let row = 0; row < gridHeight; row++) {
            for (let col = 0; col < gridWidth; col++) {
                const x = col * hexWidth * 0.75;
                const y = row * hexHeight + (col % 2) * (hexHeight / 2);
                const i = col;
                const j = row - Math.floor(col / 2);
                const k = -i - j;
                const hexagon = createHexagon(x, y, i, j, k);
                hexContainer.addChild(hexagon);
            }
        }

        let lastHighlighted = null;

        hexContainer.interactive = true;
        hexContainer.on('mousemove', (event) => {
            const pos = event.data.getLocalPosition(hexContainer);
            const col = Math.round(pos.x / (hexWidth * 0.75));
            const row = Math.round((pos.y - (col % 2) * (hexHeight / 2)) / hexHeight);
            
            if (col >= 0 && col < gridWidth && row >= 0 && row < gridHeight) {
                const index = row * gridWidth + col;
                const hexagon = hexContainer.children[index];

                if (lastHighlighted && lastHighlighted !== hexagon && !lastHighlighted.clicked) {
                    lastHighlighted.tint = 0xffffff;
                }

                if (!hexagon.clicked) {
                    hexagon.tint = 0xff0000;
                }

                lastHighlighted = hexagon;
            }
        });

        let isDragging = false;
        let dragStartX, dragStartY;

        hexContainer.on('mousedown', (event) => {
            isDragging = true;
            dragStartX = event.data.global.x - hexContainer.x;
            dragStartY = event.data.global.y - hexContainer.y;
        });

        hexContainer.on('mouseup', () => {
            isDragging = false;
        });

        hexContainer.on('mousemove', (event) => {
            if (isDragging) {
                hexContainer.x = event.data.global.x - dragStartX;
                hexContainer.y = event.data.global.y - dragStartY;
            }
        });

        document.addEventListener('wheel', (event) => {
            event.preventDefault();

            const mousePos = app.renderer.plugins.interaction.mouse.global;
            const worldPosBeforeZoom = hexContainer.toLocal(mousePos);

            const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
            hexContainer.scale.x *= zoomFactor;
            hexContainer.scale.y *= zoomFactor;

            const worldPosAfterZoom = hexContainer.toLocal(mousePos);
            hexContainer.x += (worldPosAfterZoom.x - worldPosBeforeZoom.x) * hexContainer.scale.x;
            hexContainer.y += (worldPosAfterZoom.y - worldPosBeforeZoom.y) * hexContainer.scale.y;
        });

        window.addEventListener('resize', () => {
            app.renderer.resize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
